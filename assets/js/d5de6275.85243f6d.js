"use strict";(globalThis.webpackChunkpear_docs_docusarus=globalThis.webpackChunkpear_docs_docusarus||[]).push([[9167],{370:(e,r,n)=>{n.d(r,{A:()=>t});const t=n.p+"assets/files/dict-691e655c4e8f98d8989f5c1a6b6cbdf0.json"},7431:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"how-to/replicate-and-persist-data/share-append-only-databases-with-hyperbee","title":"How to share Append-Only Databases with Hyperbee","description":"Hyperbee is an append-only B-tree based on Hypercore. It provides a key/value-store API with methods to insert and get key/value pairs, perform atomic batch insertions, and create sorted iterators.","source":"@site/docs/how-to/replicate-and-persist-data/share-append-only-databases-with-hyperbee.md","sourceDirName":"how-to/replicate-and-persist-data","slug":"/how-to/replicate-and-persist-data/share-append-only-databases-with-hyperbee","permalink":"/pear-docs/how-to/replicate-and-persist-data/share-append-only-databases-with-hyperbee","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/how-to/replicate-and-persist-data/share-append-only-databases-with-hyperbee.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"How to work with many Hypercores using Corestore","permalink":"/pear-docs/how-to/replicate-and-persist-data/manage-multiple-hypercores-with-corestore"},"next":{"title":"How to create a full peer-to-peer filesystem with Hyperdrive","permalink":"/pear-docs/how-to/replicate-and-persist-data/create-a-full-peer-to-peer-filesystem-with-hyperdrive"}}');var o=n(4848),a=n(8453);const s={},i="How to share Append-Only Databases with Hyperbee",c={},d=[];function p(e){const r={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"how-to-share-append-only-databases-with-hyperbee",children:"How to share Append-Only Databases with Hyperbee"})}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsx)(r.a,{href:"../building-blocks/hyperbee.md",children:"Hyperbee"})," is an append-only B-tree based on Hypercore. It provides a key/value-store API with methods to insert and get key/value pairs, perform atomic batch insertions, and create sorted iterators."]}),"\n",(0,o.jsxs)(r.p,{children:["This How-to consists of three applications: ",(0,o.jsx)(r.code,{children:"bee-writer-app"})," , ",(0,o.jsx)(r.code,{children:"bee-reader-app"})," and ",(0,o.jsx)(r.code,{children:"core-reader-app"}),"."]}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"bee-writer-app"})," stores 100k entries from a given dictionary file into a Hyperbee instance. The Corestore instance used to create the Hyperbee instance is replicated using Hyperswarm. This enables other peers to replicate their Corestore instance and sparsely (on-demand) download the dictionary data into their local Hyperbee instances."]}),"\n",(0,o.jsxs)(r.p,{children:["Start the ",(0,o.jsx)(r.code,{children:"bee-writer-app"})," project with the following commands:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"mkdir bee-writer-app\ncd bee-writer-app\npear init -y -t terminal\nnpm install corestore hyperswarm hyperbee b4a bare-fs\n"})}),"\n",(0,o.jsxs)(r.p,{children:[(0,o.jsxs)(r.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:n(370).A+"",children:["Click here to save ",(0,o.jsx)(r.code,{children:"dict.json"})]}),"."]}),"\n",(0,o.jsxs)(r.p,{children:["Save it into ",(0,o.jsx)(r.code,{children:"bee-writer-app"})," directory. The ",(0,o.jsx)(r.code,{children:"dict.json"})," file contains 100K dictionary words."]}),"\n",(0,o.jsxs)(r.p,{children:["Alter the generated ",(0,o.jsx)(r.code,{children:"bee-writer-app/index.js"})," file to the following"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:"import fsp from 'bare-fs/promises'\nimport Hyperswarm from 'hyperswarm'\nimport Corestore from 'corestore'\nimport Hyperbee from 'hyperbee'\nimport b4a from 'b4a'\n// create a corestore instance with the given location\nconst store = new Corestore(Pear.config.storage)\n\nconst swarm = new Hyperswarm()\nPear.teardown(() => swarm.destroy())\n\n// replication of corestore instance\nswarm.on('connection', conn => store.replicate(conn))\n\n// creation of Hypercore instance (if not already created)\nconst core = store.get({ name: 'my-bee-core' })\n\n// creation of Hyperbee instance using the core instance \nconst bee = new Hyperbee(core, {\n  keyEncoding: 'utf-8',\n  valueEncoding: 'utf-8'\n})\n\n// wait till all the properties of the hypercore are initialized\nawait core.ready()\n\n// join a topic\nconst discovery = swarm.join(core.discoveryKey)\n\n// Only display the key once the Hyperbee has been announced to the DHT\ndiscovery.flushed().then(() => {\n  console.log('bee key:', b4a.toString(core.key, 'hex'))\n})\n\n// Only import the dictionary the first time this script is executed\n// The first block will always be the Hyperbee header block\nif (core.length <= 1) {\n  console.log('importing dictionary...')\n  const dict = JSON.parse(await fsp.readFile('./dict.json'))\n  const batch = bee.batch()\n  for (const { key, value } of dict) {\n    await batch.put(key, value)\n  }\n  await batch.flush()\n} else {\n  // Otherwise just seed the previously-imported dictionary\n  console.log('seeding dictionary...')\n}\n"})}),"\n",(0,o.jsx)(r.p,{children:"Run the app with:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"pear run --dev .\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Start the ",(0,o.jsx)(r.code,{children:"bee-reader-app"})," project in a new terminal with the following commands:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"mkdir bee-reader-app\ncd bee-reader-app\npear init -y -t terminal\nnpm install corestore hyperswarm hyperbee b4a bare-pipe\n"})}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"bee-reader-app"})," creates a ",(0,o.jsx)(r.code,{children:"Corestore"})," instance and replicates it using the ",(0,o.jsx)(r.code,{children:"Hyperswarm"})," instance to the same topic as ",(0,o.jsx)(r.code,{children:"bee-writer-app"}),". On every word entered in the command line, it will download the respective data to the local ",(0,o.jsx)(r.code,{children:"Hyperbee"})," instance."]}),"\n",(0,o.jsxs)(r.p,{children:["Alter the generated ",(0,o.jsx)(r.code,{children:"bee-reader-app/index.js"})," file to the following"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:"import Hyperswarm from 'hyperswarm'\nimport Corestore from 'corestore'\nimport Hyperbee from 'hyperbee'\nimport Pipe from 'bare-pipe'\nimport b4a from 'b4a'\n\nconst key = Pear.config.args[0]\n\nif (!key) throw new Error('provide a key')\n\n// creation of a corestore instance \nconst store = new Corestore(Pear.config.storage)\n\nconst swarm = new Hyperswarm()\nPear.teardown(() => swarm.destroy())\n\n// replication of the corestore instance on connection with other peers\nswarm.on('connection', (conn) => store.replicate(conn))\n\n// create or get the hypercore using the public key supplied as command-line argument\nconst core = store.get({ key: b4a.from(key, 'hex') })\n\n// create a hyperbee instance using the hypercore instance\nconst bee = new Hyperbee(core, {\n  keyEncoding: 'utf-8',\n  valueEncoding: 'utf-8'\n})\n\n// wait till the hypercore properties to be initialized\nawait core.ready()\n\n// logging the public key of the hypercore instance\nconsole.log('core key here is:', core.key.toString('hex'))\n\n// Attempt to connect to peers\nswarm.join(core.discoveryKey)\n\nconst stdin = new Pipe(0)\n\nstdin.on('data', (data) => {\n  const word = data.toString().trim()\n  if (!word.length) return\n  bee.get(word).then(node => {\n    if (!node || !node.value) console.log(`No dictionary entry for ${word}`)\n    else console.log(`${word} -> ${node.value}`)\n    setImmediate(console.log) // flush hack\n  }, console.error)\n})\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Open the ",(0,o.jsx)(r.code,{children:"bee-reader-app"})," and pass it the core key:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"pear run --dev . <SUPPLY KEY HERE>\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Query the database by entering a key to lookup into the ",(0,o.jsx)(r.code,{children:"bee-reader-app"})," terminal and hitting return."]}),"\n",(0,o.jsxs)(r.p,{children:["Each application has dedicated storage at ",(0,o.jsx)(r.code,{children:"Pear.config.storage"}),". Try logging out ",(0,o.jsx)(r.code,{children:"Pear.config.storage"})," for the ",(0,o.jsx)(r.code,{children:"bee-reader-app"})," and then look at the disk space for that storage path after each query. Notice that it's significantly smaller than ",(0,o.jsx)(r.code,{children:"bee-writer-app"}),"! This is because Hyperbee only downloads the Hypercore blocks it needs to satisfy each query, a feature we call ",(0,o.jsx)(r.strong,{children:"sparse downloading."})]}),"\n",(0,o.jsxs)(r.p,{children:["Importantly, a Hyperbee is ",(0,o.jsx)(r.strong,{children:"just"})," a Hypercore, where the tree nodes are stored as Hypercore blocks."]}),"\n",(0,o.jsxs)(r.p,{children:["Finally create a ",(0,o.jsx)(r.code,{children:"core-reader-app"})," project:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"mkdir core-reader-app\ncd core-reader-app\npear init -y -t terminal\nnpm install corestore hyperswarm hyperbee b4a\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Alter the generated ",(0,o.jsx)(r.code,{children:"core-reader-app/index.js"})," file to the following"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-javascript",children:"import Hyperswarm from 'hyperswarm'\nimport Corestore from 'corestore'\nimport b4a from 'b4a'\n\nimport { Node } from 'hyperbee/lib/messages.js'\n\nconst key = Pear.config.args[0]\nif (!key) throw new Error('provide a key')\n\n// creation of a corestore instance \nconst store = new Corestore('./reader-storage')\n\nconst swarm = new Hyperswarm()\nPear.teardown(() => swarm.destroy())\n\n// replication of the corestore instance on connection with other peers\nswarm.on('connection', conn => store.replicate(conn))\n\n// create or get the hypercore using the public key supplied as command-line argument\nconst core = store.get({ key: b4a.from(key, 'hex') })\n// wait till the properties of the hypercore instance are initialized\nawait core.ready()\n\n// join a topic\nswarm.join(core.discoveryKey)\nawait swarm.flush()\n\n// update the meta-data information of the hypercore instance\nawait core.update()\n\nconst seq = core.length - 1\nconst lastBlock = await core.get(core.length - 1)\n\n// print the information about the last block or the latest block of the hypercore instance\nconsole.log(`Raw Block ${seq}:`, lastBlock)\nconsole.log(`Decoded Block ${seq}`, Node.decode(lastBlock))\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Open the ",(0,o.jsx)(r.code,{children:"core-reader-app"})," with ",(0,o.jsx)(r.code,{children:"pear run --dev ."}),", passing the core key to it:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"pear run --dev . <SUPPLY KEY HERE>\n"})}),"\n",(0,o.jsx)(r.p,{children:"Now we can examine the Hyperbee as if it were just a Hypercore."}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"core-reader-app"})," will continually download and log the last block of the Hypercore containing the Hyperbee data. Note that these blocks are encoded using Hyperbee's ",(0,o.jsx)(r.code,{children:"Node"})," encoding, which has been imported directly from ",(0,o.jsx)(r.code,{children:"Hyperbee"})," here for the purposes of explanation."]})]})}function l(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>s,x:()=>i});var t=n(6540);const o={},a=t.createContext(o);function s(e){const r=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);