"use strict";(globalThis.webpackChunkpear_docs_docusarus=globalThis.webpackChunkpear_docs_docusarus||[]).push([[4345],{8453:(e,n,o)=>{o.d(n,{R:()=>t,x:()=>l});var s=o(6540);const r={},c=s.createContext(r);function t(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(c.Provider,{value:n},e.children)}},9102:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"references/helpers/protomux","title":"Protomux","description":"Multiplex multiple message-oriented protocols over a stream","source":"@site/docs/references/helpers/protomux.md","sourceDirName":"references/helpers","slug":"/references/helpers/protomux","permalink":"/pear-docs/references/helpers/protomux","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/references/helpers/protomux.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"MirrorDrive","permalink":"/pear-docs/references/helpers/mirrordrive"},"next":{"title":"SecretStream","permalink":"/pear-docs/references/helpers/secretstream"}}');var r=o(4848),c=o(8453);const t={},l="Protomux",a={},d=[{value:"Installation",id:"installation",level:3},{value:"Basic usage",id:"basic-usage",level:3},{value:"API",id:"api",level:3},{value:"<strong><code>mux = new Protomux(stream, [options])</code></strong>",id:"mux--new-protomuxstream-options",level:4},{value:"<strong><code>mux = Protomux.from(stream | muxer, [options])</code></strong>",id:"mux--protomuxfromstream--muxer-options",level:4},{value:"<strong><code>const opened = mux.opened({ protocol, id })</code></strong>",id:"const-opened--muxopened-protocol-id-",level:4},{value:"<strong><code>mux.pair({ protocol, id }, callback)</code></strong>",id:"muxpair-protocol-id--callback",level:4},{value:"<strong><code>mux.unpair({ protocol, id })</code></strong>",id:"muxunpair-protocol-id-",level:4},{value:"<strong><code>channel.open([handshake])</code></strong>",id:"channelopenhandshake",level:4},{value:"<strong><code>const m = channel.addMessage([options])</code></strong>",id:"const-m--channeladdmessageoptions",level:4},{value:"<strong><code>m.send(data)</code></strong>",id:"msenddata",level:4},{value:"<strong><code>m.onmessage</code></strong>",id:"monmessage",level:4},{value:"<strong><code>m.encoding</code></strong>",id:"mencoding",level:4},{value:"<strong><code>channel.close()</code></strong>",id:"channelclose",level:4},{value:"<strong><code>channel.cork()</code></strong>",id:"channelcork",level:4},{value:"<strong><code>channel.uncork()</code></strong>",id:"channeluncork",level:4},{value:"<strong><code>mux.cork()</code></strong>",id:"muxcork",level:4},{value:"<strong><code>mux.uncork()</code></strong>",id:"muxuncork",level:4},{value:"<strong><code>for (const channel of muxer) { ... }</code></strong>",id:"for-const-channel-of-muxer---",level:4}];function i(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"protomux",children:"Protomux"})}),"\n",(0,r.jsx)(n.p,{children:"Multiplex multiple message-oriented protocols over a stream"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/holepunchto/protomux",children:"GitHub (Protomux)"})}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/pear-docs/references/helpers/protomux#installation",children:"Installation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/pear-docs/references/helpers/protomux#basic-usage",children:"Basic usage"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/pear-docs/references/helpers/protomux#api",children:"API"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,r.jsxs)(n.p,{children:["Install with ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/",children:"npm"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install protomux\n"})}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage",children:"Basic usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const Protomux = require('protomux')\nconst c = require('compact-encoding')\n\n// By framed stream, it has be a stream that preserves the messages, ie something that length prefixes\n// like @hyperswarm/secret-stream\n\nconst mux = new Protomux(aStreamThatFrames)\n\n// Now add some protocol channels\n\nconst cool = mux.createChannel({\n  protocol: 'cool-protocol',\n  id: Buffer.from('optional binary id'),\n  onopen () {\n    console.log('the other side opened this protocol!')\n  },\n  onclose () {\n    console.log('either side closed the protocol')\n  }\n})\n\n// And add some messages\n\nconst one = cool.addMessage({\n  encoding: c.string,\n  onmessage (m) {\n    console.log('recv message (1)', m)\n  }\n})\n\nconst two = cool.addMessage({\n  encoding: c.bool,\n  onmessage (m) {\n    console.log('recv message (2)', m)\n  }\n})\n\n// open the channel\n\ncool.open()\n\n// And send some data\n\none.send('a string')\ntwo.send(true)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"api",children:"API"}),"\n",(0,r.jsx)(n.h4,{id:"mux--new-protomuxstream-options",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mux = new Protomux(stream, [options])"})})}),"\n",(0,r.jsxs)(n.p,{children:["Makes a new instance. ",(0,r.jsx)(n.code,{children:"stream"})," should be a framed stream, preserving the messages written."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"options"})," include:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n  // Called when the muxer needs to allocate a message that is written, defaults to Buffer.allocUnsafe.\n  alloc (size) {}\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"mux--protomuxfromstream--muxer-options",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mux = Protomux.from(stream | muxer, [options])"})})}),"\n",(0,r.jsx)(n.p,{children:"Helper to accept either an existing muxer instance or a stream (which creates a new one)."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"const channel = mux.createChannel([options])"})})}),"\n",(0,r.jsx)(n.p,{children:"Adds a new protocol channel."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"options"})," include:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n  // Used to match the protocol\n  protocol: 'name of the protocol',\n  // Optional additional binary id to identify this channel\n  id: buffer,\n  // Optional encoding for a handshake\n  handshake: encoding,\n  // Optional array of message types to send/receive.\n  messages: [],\n  // Called when the remote side adds this protocol.\n  // Errors here are caught and forwarded to stream.destroy\n  async onopen (handshake) {},\n  // Called when the channel closes - ie the remote side closes or rejects this protocol or we closed it.\n  // Errors here are caught and forwarded to stream.destroy\n  async onclose () {},\n  // Called after onclose when all pending promises have been resolved.\n  async ondestroy () {}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Sessions are paired based on a queue, so the first remote channel with the same ",(0,r.jsx)(n.code,{children:"protocol"})," and ",(0,r.jsx)(n.code,{children:"id"}),"."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"mux.createChannel"})," returns ",(0,r.jsx)(n.code,{children:"null"})," if the channel should not be opened, it's a duplicate channel or the remote has already closed this one. To have multiple sessions with the same ",(0,r.jsx)(n.code,{children:"protocol"})," and ",(0,r.jsx)(n.code,{children:"id"}),", set ",(0,r.jsx)(n.code,{children:"unique: false"})," as an option."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"const-opened--muxopened-protocol-id-",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"const opened = mux.opened({ protocol, id })"})})}),"\n",(0,r.jsx)(n.p,{children:"Boolean that indicates if the channel is opened."}),"\n",(0,r.jsx)(n.h4,{id:"muxpair-protocol-id--callback",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mux.pair({ protocol, id }, callback)"})})}),"\n",(0,r.jsx)(n.p,{children:"Registers a callback to be called every time a new channel is requested."}),"\n",(0,r.jsx)(n.h4,{id:"muxunpair-protocol-id-",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mux.unpair({ protocol, id })"})})}),"\n",(0,r.jsx)(n.p,{children:"Unregisters the pair callback."}),"\n",(0,r.jsx)(n.h4,{id:"channelopenhandshake",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"channel.open([handshake])"})})}),"\n",(0,r.jsx)(n.p,{children:"Opens the channel."}),"\n",(0,r.jsx)(n.h4,{id:"const-m--channeladdmessageoptions",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"const m = channel.addMessage([options])"})})}),"\n",(0,r.jsx)(n.p,{children:"Adds/registers a message type for a specific encoding. Options include:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n  // compact-encoding specifying how to encode/decode this message\n  encoding: c.binary,\n  // Called when the remote side sends a message.\n  // Errors here are caught and forwared to stream.destroy\n  async onmessage (message) { }\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"msenddata",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"m.send(data)"})})}),"\n",(0,r.jsx)(n.p,{children:"Sends a message."}),"\n",(0,r.jsx)(n.h4,{id:"monmessage",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"m.onmessage"})})}),"\n",(0,r.jsx)(n.p,{children:"The function that is called when a message arrives."}),"\n",(0,r.jsx)(n.h4,{id:"mencoding",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"m.encoding"})})}),"\n",(0,r.jsx)(n.p,{children:"The encoding for this message."}),"\n",(0,r.jsx)(n.h4,{id:"channelclose",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"channel.close()"})})}),"\n",(0,r.jsx)(n.p,{children:"Closes the protocol channel."}),"\n",(0,r.jsx)(n.h4,{id:"channelcork",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"channel.cork()"})})}),"\n",(0,r.jsx)(n.p,{children:"Corking the protocol channel, makes it buffer messages and sends them all in a batch when it uncorks."}),"\n",(0,r.jsx)(n.h4,{id:"channeluncork",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"channel.uncork()"})})}),"\n",(0,r.jsx)(n.p,{children:"Uncorks and send the batch."}),"\n",(0,r.jsx)(n.h4,{id:"muxcork",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mux.cork()"})})}),"\n",(0,r.jsxs)(n.p,{children:["Same as ",(0,r.jsx)(n.code,{children:"channel.cork"})," but on the muxer instance."]}),"\n",(0,r.jsx)(n.h4,{id:"muxuncork",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"mux.uncork()"})})}),"\n",(0,r.jsxs)(n.p,{children:["Same as ",(0,r.jsx)(n.code,{children:"channel.uncork"})," but on the muxer instance."]}),"\n",(0,r.jsx)(n.h4,{id:"for-const-channel-of-muxer---",children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"for (const channel of muxer) { ... }"})})}),"\n",(0,r.jsx)(n.p,{children:"The muxer instance is iterable so all channels can be iterated."})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}}}]);