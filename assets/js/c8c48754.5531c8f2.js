"use strict";(globalThis.webpackChunkpear_docs_docusarus=globalThis.webpackChunkpear_docs_docusarus||[]).push([[3335],{4350:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"references/helpers/corestore","title":"Corestore","description":"stable","source":"@site/docs/references/helpers/corestore.md","sourceDirName":"references/helpers","slug":"/references/helpers/corestore","permalink":"/pear-docs/references/helpers/corestore","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/references/helpers/corestore.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Compact Encoding","permalink":"/pear-docs/references/helpers/compact-encoding"},"next":{"title":"Localdrive","permalink":"/pear-docs/references/helpers/localdrive"}}');var t=r(4848),o=r(8453);const c={},i="Corestore",a={},l=[{value:"Installation",id:"installation",level:3},{value:"API",id:"api",level:3},{value:"<strong><code>const store = new Corestore(storage, [options])</code></strong>",id:"store-new",level:4},{value:"<strong><code>const core = store.get(key | { key, name, exclusive, [options] })</code></strong>",id:"store.get",level:4},{value:"<strong><code>const stream = store.replicate(options|stream)</code></strong>",id:"store.replicate",level:4},{value:"<strong><code>const store = store.namespace(name)</code></strong>",id:"store.namespace",level:4},{value:"<code>const session = store.session([options])</code>",id:"store.session",level:4}];function d(e){const s={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"corestore",children:"Corestore"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"stable"})}),"\n",(0,t.jsxs)(s.p,{children:["Corestore is a Hypercore factory that makes it easier to manage large collections of named Hypercores. It is designed to efficiently store and replicate multiple sets of interlinked ",(0,t.jsx)(s.a,{href:"/pear-docs/references/building-blocks/hypercore",children:(0,t.jsx)(s.code,{children:"Hypercore"})}),"(s), such as those used by ",(0,t.jsx)(s.a,{href:"/pear-docs/references/building-blocks/hyperdrive",children:(0,t.jsx)(s.code,{children:"Hyperdrive"})}),", removing the responsibility of managing custom storage/replication code from these higher-level modules."]}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.a,{href:"https://github.com/holepunchto/corestore",children:"GitHub (Corestore)"})}),"\n"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.a,{href:"/pear-docs/references/helpers/corestore#installation",children:"Corestore"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"/pear-docs/references/helpers/corestore#store-new",children:"Create a new instance"})}),"\n",(0,t.jsxs)(s.li,{children:["Basic:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Methods:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"/pear-docs/references/helpers/corestore#store.get",children:(0,t.jsx)(s.code,{children:"store.get(key | { key, name, exclusive, [options] })"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"/pear-docs/references/helpers/corestore#store.replicate",children:(0,t.jsx)(s.code,{children:"store.replicate(options|stream)"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"/pear-docs/references/helpers/corestore#store.namespace",children:(0,t.jsx)(s.code,{children:"store.namespace(name)"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"/pear-docs/references/helpers/corestore#store.sesssion",children:(0,t.jsx)(s.code,{children:"store.session(\\[options\\])"})})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"installation",children:"Installation"}),"\n",(0,t.jsxs)(s.p,{children:["Install with ",(0,t.jsx)(s.a,{href:"https://www.npmjs.com/",children:"npm"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"npm install corestore\n"})}),"\n",(0,t.jsx)(s.h3,{id:"api",children:"API"}),"\n",(0,t.jsx)(s.h4,{id:"store-new",children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"const store = new Corestore(storage, [options])"})})}),"\n",(0,t.jsx)(s.p,{children:"Creates a new Corestore instance."}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"storage"})," can be either a random-access-storage module, a string, or a function that takes a path and returns a random-access-storage instance."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"const Corestore = require('corestore')\nconst store = new Corestore('./my-storage')\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"options"})," can include:"]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Property"}),(0,t.jsx)(s.th,{children:"Description"}),(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Default"})]})}),(0,t.jsx)(s.tbody,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"primaryKey"})})}),(0,t.jsx)(s.td,{children:"The primary key used to generate new Hypercore key pairs"}),(0,t.jsx)(s.td,{children:"Buffer"}),(0,t.jsx)(s.td,{children:"Randomly generated and persisted in the storage directory"})]})})]}),"\n",(0,t.jsx)(s.h4,{id:"store.get",children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"const core = store.get(key | { key, name, exclusive, [options] })"})})}),"\n",(0,t.jsxs)(s.p,{children:["Loads a Hypercore, either by name (if the ",(0,t.jsx)(s.code,{children:"name"})," option is provided), or from the provided key (if the first argument is a Buffer or String with hex/z32 key, or if the ",(0,t.jsx)(s.code,{children:"key"})," option is set)."]}),"\n",(0,t.jsxs)(s.p,{children:["If that Hypercore has previously been loaded, subsequent calls to ",(0,t.jsx)(s.code,{children:"get"})," will return a new Hypercore session on the existing core."]}),"\n",(0,t.jsxs)(s.p,{children:["If the ",(0,t.jsx)(s.code,{children:"exclusive"})," option is set and a writable session is opened, it will wait for all other exclusive writable to close before\nopening the Hypercore. In other words, any operation on the core will wait until it is exclusive."]}),"\n",(0,t.jsxs)(s.p,{children:["All other options besides ",(0,t.jsx)(s.code,{children:"name"})," and ",(0,t.jsx)(s.code,{children:"key"})," and ",(0,t.jsx)(s.code,{children:"exclusive"})," will be forwarded to the Hypercore constructor."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"// assuming store is a Corestore instance\nconst core1 = store.get({ name: 'my-core-1' })\nconst core2 = store.get({ name: 'my-core-2' })\n\n// awaiting ready so that we can access core1.key\nawait core1.ready()\nconst core3 = store.get({ key: core1.key }) // will open another session on core1\n\n// assuming otherKey is the key to a non-writable core\n// these are equivalent and will both return sessions on that same non-writable core\nconst core4 = store.get({ key: otherKey })\nconst core5 = store.get(otherKey)\n"})}),"\n",(0,t.jsxs)(s.blockquote,{children:["\n",(0,t.jsxs)(s.p,{children:["The names provided are only relevant ",(0,t.jsx)(s.strong,{children:"locally"}),", in that they are used to deterministically generate key pairs. Whenever a core is loaded by name, that core will be writable. Names are not shared with remote peers."]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"store.replicate",children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"const stream = store.replicate(options|stream)"})})}),"\n",(0,t.jsx)(s.p,{children:"Creates a replication stream that's capable of replicating all Hypercores that are managed by the Corestore, assuming the remote peer has the correct capabilities."}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"options"})," will be forwarded to Hypercore's ",(0,t.jsx)(s.code,{children:"replicate"})," function."]}),"\n",(0,t.jsx)(s.p,{children:"Corestore replicates in an 'all-to-all' fashion, meaning that when replication begins, it will attempt to replicate every Hypercore that's currently loaded and in memory. These attempts will fail if the remote side doesn't have a Hypercore's capability -- Corestore replication does not exchange Hypercore keys."}),"\n",(0,t.jsxs)(s.p,{children:["If the remote side dynamically adds a new Hypercore to the replication stream (by opening that core with a ",(0,t.jsx)(s.code,{children:"get"})," on their Corestore, for example), Corestore will load and replicate that core if possible."]}),"\n",(0,t.jsxs)(s.p,{children:["Using ",(0,t.jsx)(s.a,{href:"/pear-docs/references/building-blocks/hyperswarm",children:(0,t.jsx)(s.code,{children:"Hyperswarm"})})," one can replicate Corestores as follows:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"const swarm = new Hyperswarm()\n// join the relevant topic\nswarm.join(...)\n// simply pass the connection stream to corestore\nswarm.on('connection', conn => store.replicate(conn))\n"})}),"\n",(0,t.jsxs)(s.p,{children:["As with Hypercore, users can also create new protocol streams by treating ",(0,t.jsx)(s.code,{children:"options"})," as the ",(0,t.jsx)(s.code,{children:"isInitiator"})," boolean and then replicate these streams over a transport layer of their choosing:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"// assuming store1 and store2 are corestore instances\nconst s1 = store1.replicate(true)\nconst s2 = store2.replicate(false)\ns1.pipe(s2).pipe(s1)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"store.namespace",children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"const store = store.namespace(name)"})})}),"\n",(0,t.jsx)(s.p,{children:"Creates a new namespaced Corestore. Namespacing is useful for sharing a single Corestore instance between many applications or components, as it prevents name collisions."}),"\n",(0,t.jsx)(s.p,{children:"Namespaces can be chained:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"const ns1 = store.namespace('a')\nconst ns2 = ns1.namespace('b')\nconst core1 = ns1.get({ name: 'main' }) // These will load different Hypercores\nconst core2 = ns2.get({ name: 'main' })\n"})}),"\n",(0,t.jsxs)(s.p,{children:["Namespacing is particularly useful if an application needs to create many different data structures, such as ",(0,t.jsx)(s.a,{href:"/pear-docs/references/building-blocks/hyperdrive",children:(0,t.jsx)(s.code,{children:"Hyperdrive"})}),"s, that all share a common storage location:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-javascript",children:"const store = new Corestore('./my-storage-dir')\n\n// Neither drive1 nor drive2 care that they're being passed a namespaced store.\n// But the top-level application can safely reuse my-storage-dir between both.\nconst drive1 = new Hyperdrive(store.namespace('drive-a'))\nconst drive2 = new Hyperdrive(store.namespace('drive-b'))\n"})}),"\n",(0,t.jsx)(s.h4,{id:"store.session",children:(0,t.jsx)(s.code,{children:"const session = store.session([options])"})}),"\n",(0,t.jsxs)(s.p,{children:["Creates a new Corestore that shares resources with the original, like cache, cores, replication streams, and storage, while optionally resetting the namespace, overriding ",(0,t.jsx)(s.code,{children:"primaryKey"}),". Useful when an application needs to accept an optional Corestore, but needs to maintain a predictable key derivation."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"options"})," are the same as the constructor options:"]}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Property"}),(0,t.jsx)(s.th,{children:"Description"}),(0,t.jsx)(s.th,{children:"Type"}),(0,t.jsx)(s.th,{children:"Default"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"primaryKey"})})}),(0,t.jsxs)(s.td,{children:["Overrides the default ",(0,t.jsx)(s.code,{children:"primaryKey"})," for this session"]}),(0,t.jsx)(s.td,{children:"Buffer"}),(0,t.jsxs)(s.td,{children:["The store's current ",(0,t.jsx)(s.code,{children:"primaryKey"})]})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"namespace"})})}),(0,t.jsxs)(s.td,{children:["Overrides the namespace for this session. If ",(0,t.jsx)(s.code,{children:"null"}),", the default namespace will be used."]}),(0,t.jsx)(s.td,{children:"Buffer"}),(0,t.jsx)(s.td,{children:"The store's current namespace."})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"detach"})})}),(0,t.jsx)(s.td,{children:"By disabling this, closing the session will also close the store that created the session."}),(0,t.jsx)(s.td,{children:"Boolean"}),(0,t.jsx)(s.td,{children:(0,t.jsx)(s.code,{children:"true"})})]})]})]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,r)=>{r.d(s,{R:()=>c,x:()=>i});var n=r(6540);const t={},o=n.createContext(t);function c(e){const s=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);