"use strict";(globalThis.webpackChunkpear_docs_docusarus=globalThis.webpackChunkpear_docs_docusarus||[]).push([[6601],{381:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>c,contentTitle:()=>o,default:()=>a,frontMatter:()=>l,metadata:()=>d,toc:()=>t});const d=JSON.parse('{"id":"references/building-blocks/hyperdrive","title":"Hyperdrive","description":"Hyperdrive is a secure, real-time distributed file system designed for easy P2P file sharing. We use it extensively inside Holepunch; apps like Keet are distributed to users as Hyperdrives, as is the Holepunch platform itself.","source":"@site/docs/references/building-blocks/hyperdrive.md","sourceDirName":"references/building-blocks","slug":"/references/building-blocks/hyperdrive","permalink":"/pear-docs/references/building-blocks/hyperdrive","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/references/building-blocks/hyperdrive.md","tags":[],"version":"current","frontMatter":{}}');var n=i(4848),s=i(8453);const l={},o="Hyperdrive",c={},t=[{value:"Installation",id:"installation",level:3},{value:"API",id:"api",level:3},{value:"<strong><code>const drive = new Hyperdrive(store, [key])</code></strong>",id:"const-drive--new-hyperdrivestore-key",level:4},{value:"Properties",id:"properties",level:4},{value:"<strong><code>drive.corestore</code></strong>",id:"drive.corestore",level:4},{value:"<strong><code>drive.db</code></strong>",id:"drive.db",level:4},{value:"<strong><code>drive.core</code></strong>",id:"drive.core",level:4},{value:"<strong><code>drive.id</code></strong>",id:"drive.id",level:4},{value:"<strong><code>drive.key</code></strong>",id:"drive.key",level:4},{value:"<strong><code>drive.writable</code></strong>",id:"drive.writable",level:4},{value:"<strong><code>drive.readable</code></strong>",id:"drive.readable",level:4},{value:"<strong><code>drive.discoveryKey</code></strong>",id:"drive.discoverykey",level:4},{value:"<strong><code>drive.contentKey</code></strong>",id:"drive.contentkey",level:4},{value:"<strong><code>drive.version</code></strong>",id:"drive.version",level:4},{value:"<strong><code>drive.supportsMetadata</code></strong>",id:"drive.supportsmetadata",level:4},{value:"Methods",id:"methods",level:4},{value:"<strong><code>await drive.ready()</code></strong>",id:"drive.ready",level:4},{value:"<strong><code>await drive.close()</code></strong>",id:"drive.close",level:4},{value:"<strong><code>await drive.put(path, buffer, [options])</code></strong>",id:"drive.put",level:4},{value:"<strong><code>const buffer = await drive.get(path, [options])</code></strong>",id:"drive.get",level:4},{value:"<strong><code>const entry = await drive.entry(path, [options])</code></strong>",id:"drive.entry",level:4},{value:"<code>const exists = await drive.exists(path)</code>",id:"drive.exists",level:4},{value:"<strong><code>await drive.del(path)</code></strong>",id:"drive.del",level:4},{value:"<strong><code>const comparison = drive.compare(entryA, entryB)</code></strong>",id:"drive.compare",level:4},{value:"<strong><code>const cleared = await drive.clear(path, [options])</code></strong>",id:"drive.clear",level:4},{value:"<code>const cleared = await drive.clearAll([options])</code>",id:"drive.clearall",level:4},{value:"<code>await drive.purge()</code>",id:"drive.purge",level:4},{value:"<strong><code>await drive.symlink(path, linkname)</code></strong>",id:"drive.symlink",level:4},{value:"<strong><code>const batch = drive.batch()</code></strong>",id:"drive.batch",level:4},{value:"<strong><code>await batch.flush()</code></strong>",id:"drive.flush",level:4},{value:"<strong><code>const stream = drive.list(folder, [options])</code></strong>",id:"drive.list",level:4},{value:"<strong><code>const stream = drive.readdir(folder)</code></strong>",id:"drive.readdir",level:4},{value:"<strong><code>const stream = await drive.entries([range], [options])</code></strong>",id:"drive.entries",level:4},{value:"<strong><code>const mirror = drive.mirror(out, [options])</code></strong>",id:"drive.mirror",level:4},{value:"<strong><code>const watcher = drive.watch([folder])</code></strong>",id:"drive.watch",level:4},{value:"<strong><code>const rs = drive.createReadStream(path, [options])</code></strong>",id:"drive.createreadstream",level:4},{value:"<strong><code>const ws = drive.createWriteStream(path, [options])</code></strong>",id:"drive.createwritestream",level:4},{value:"<strong><code>await drive.download(folder, [options])</code></strong>",id:"drive.download",level:4},{value:"<strong><code>const snapshot = drive.checkout(version)</code></strong>",id:"drive.checkout",level:4},{value:"<strong><code>const stream = drive.diff(version, folder, [options])</code></strong>",id:"drive.diff",level:4},{value:"<strong><code>await drive.downloadDiff(version, folder, [options])</code></strong>",id:"drive.downloaddiff",level:4},{value:"<strong><code>await drive.downloadRange(dbRanges, blobRanges)</code></strong>",id:"drive.downloadrange",level:4},{value:"<strong><code>const done = drive.findingPeers()</code></strong>",id:"drive.findingpeers",level:4},{value:"<strong><code>const stream = drive.replicate(isInitiatorOrStream)</code></strong>",id:"drive.replicate",level:4},{value:"<strong><code>const updated = await drive.update([options])</code></strong>",id:"drive.update",level:4},{value:"<strong><code>const blobs = await drive.getBlobs()</code></strong>",id:"drive.getblobs",level:4}];function h(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"hyperdrive",children:"Hyperdrive"})}),"\n",(0,n.jsx)(r.p,{children:"Hyperdrive is a secure, real-time distributed file system designed for easy P2P file sharing. We use it extensively inside Holepunch; apps like Keet are distributed to users as Hyperdrives, as is the Holepunch platform itself."}),"\n",(0,n.jsx)(r.p,{children:"Notable features include:"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"Uses Hyperbee internally for storing file metadata"}),"\n",(0,n.jsx)(r.li,{children:"Major API simplification. Instead of mirroring POSIX APIs, the new API better captures the core requirements of P2P file transfer."}),"\n",(0,n.jsxs)(r.li,{children:["Auxiliary tools, ",(0,n.jsx)(r.a,{href:"/pear-docs/references/helpers/localdrive",children:(0,n.jsx)(r.code,{children:"localdrive"})})," and ",(0,n.jsx)(r.a,{href:"/pear-docs/references/helpers/mirrordrive",children:(0,n.jsx)(r.code,{children:"mirrordrive"})}),", that streamline import/export flows and make it easy to mirror drives to and from the local filesystem."]}),"\n"]}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.a,{href:"https://github.com/holepunchto/hyperdrive",children:"GitHub (Hyperdrive)"})}),"\n"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive",children:"Hyperdrive"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#installation",children:"Create a new instance"})}),"\n",(0,n.jsxs)(r.li,{children:["Basic:","\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:["Properties:","\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.corestore",children:"drive.corestore"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.db",children:"drive.db"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.core",children:"drive.core"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.id",children:"drive.id"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.key",children:"drive.key"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.writable",children:"drive.writable"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.readable",children:"drive.readable"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.discoverykey",children:"drive.discoveryKey"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.contentkey",children:"drive.contentKey"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.version",children:"drive.version"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.supportsmetadata",children:"drive.supportsMetadata"})}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(r.li,{children:["Methods:","\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.ready",children:"drive.ready()"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.close",children:"drive.close()"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.put",children:"drive.put(path, buffer, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.get",children:"drive.get(path, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.entry",children:"drive.entry(path, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.exists",children:"drive.exists(path)"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.del",children:"drive.del(path)"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.compare",children:"drive.compare(entryA, entryB)"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.clear",children:"drive.clear(path, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.clearall",children:"drive.clearAll([options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.purge",children:"drive.purge()"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.symlink",children:"drive.symlink(path, linkname)"})}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.batch",children:"drive.batch()"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.batch",children:"batch.flush()"})}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.list",children:"drive.list(folder, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.readdir",children:"drive.readdir(folder)"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.entries",children:"drive.entries([range], [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.mirror",children:"drive.mirror(out, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.watch",children:"drive.watch([folder])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.createreadstream",children:"drive.createReadStream(path, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.createwritestream",children:"drive.createWriteStream(path, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.download",children:"drive.download(folder, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.checkout",children:"drive.checkout(version)"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.diff",children:"drive.diff(version, folder, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.downloaddiff",children:"drive.downloadDiff(version, folder, [options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.downloadrange",children:"drive.downloadRange(dbRanges, blobRanges)"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.findingpeers",children:"drive.findingPeers()"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.replicate",children:"drive.replicate(isInitiatorOrStream)"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.update",children:"drive.update([options])"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/pear-docs/references/building-blocks/hyperdrive#drive.getblobs",children:"drive.getBlobs()"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"installation",children:"Installation"}),"\n",(0,n.jsxs)(r.p,{children:["Install with ",(0,n.jsx)(r.a,{href:"https://www.npmjs.com/",children:"npm"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-bash",children:"npm install hyperdrive\n"})}),"\n",(0,n.jsx)(r.h3,{id:"api",children:"API"}),"\n",(0,n.jsx)(r.h4,{id:"const-drive--new-hyperdrivestore-key",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const drive = new Hyperdrive(store, [key])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Creates a new Hyperdrive instance. ",(0,n.jsx)(r.code,{children:"store"})," must be an instance of ",(0,n.jsx)(r.a,{href:"/pear-docs/references/helpers/corestore",children:(0,n.jsx)(r.code,{children:"Corestore"})}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["By default, it uses the core at ",(0,n.jsx)(r.code,{children:"{ name: 'db' }"})," from ",(0,n.jsx)(r.code,{children:"store"}),", unless the public ",(0,n.jsx)(r.code,{children:"key"})," is set."]}),"\n",(0,n.jsx)(r.h4,{id:"properties",children:"Properties"}),"\n",(0,n.jsx)(r.h4,{id:"drive.corestore",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.corestore"})})}),"\n",(0,n.jsx)(r.p,{children:"The Corestore instance used as storage."}),"\n",(0,n.jsx)(r.h4,{id:"drive.db",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.db"})})}),"\n",(0,n.jsx)(r.p,{children:"The underlying Hyperbee backing the drive file structure."}),"\n",(0,n.jsx)(r.h4,{id:"drive.core",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.core"})})}),"\n",(0,n.jsxs)(r.p,{children:["The Hypercore used for ",(0,n.jsx)(r.code,{children:"drive.db"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.id",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.id"})})}),"\n",(0,n.jsx)(r.p,{children:"String containing the id (z-base-32 of the public key) identifying this drive."}),"\n",(0,n.jsx)(r.h4,{id:"drive.key",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.key"})})}),"\n",(0,n.jsx)(r.p,{children:"The public key of the Hypercore backing the drive."}),"\n",(0,n.jsx)(r.h4,{id:"drive.writable",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.writable"})})}),"\n",(0,n.jsx)(r.p,{children:"Boolean indicating if we can write or delete data in this drive."}),"\n",(0,n.jsx)(r.h4,{id:"drive.readable",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.readable"})})}),"\n",(0,n.jsxs)(r.p,{children:["Boolean indicating if we can read from this drive. After closing the drive this will be ",(0,n.jsx)(r.code,{children:"false"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.discoverykey",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.discoveryKey"})})}),"\n",(0,n.jsxs)(r.p,{children:["The hash of the public key of the Hypercore backing the drive. It can be used as a ",(0,n.jsx)(r.code,{children:"topic"})," to seed the drive using Hyperswarm."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.contentkey",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.contentKey"})})}),"\n",(0,n.jsxs)(r.p,{children:["The public key of the ",(0,n.jsx)(r.a,{href:"https://github.com/holepunchto/hyperblobs",children:"Hyperblobs"})," instance holding blobs associated with entries in the drive."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.version",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.version"})})}),"\n",(0,n.jsx)(r.p,{children:"The number that indicates how many modifications were made, it is useful as a version identifier."}),"\n",(0,n.jsx)(r.h4,{id:"drive.supportsmetadata",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"drive.supportsMetadata"})})}),"\n",(0,n.jsxs)(r.p,{children:["Boolean indicating if the drive handles or not metadata. Always ",(0,n.jsx)(r.code,{children:"true"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"methods",children:"Methods"}),"\n",(0,n.jsx)(r.h4,{id:"drive.ready",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.ready()"})})}),"\n",(0,n.jsx)(r.p,{children:"Waits until the internal state is loaded."}),"\n",(0,n.jsxs)(r.p,{children:["Use it once before reading synchronous properties like ",(0,n.jsx)(r.code,{children:"drive.discoveryKey"}),".\nIf any of the other APIs are called first they will wait for readiness so this is only needed to lookup\nsynchronous properties before any API call."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.close",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.close()"})})}),"\n",(0,n.jsx)(r.p,{children:"Fully close this drive, including its underlying Hypercore backed data structures."}),"\n",(0,n.jsx)(r.h4,{id:"drive.put",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.put(path, buffer, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Creates a file at ",(0,n.jsx)(r.code,{children:"path"})," in the drive. ",(0,n.jsx)(r.code,{children:"options"})," are the same as in ",(0,n.jsx)(r.code,{children:"createWriteStream"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.get",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const buffer = await drive.get(path, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns the blob at ",(0,n.jsx)(r.code,{children:"path"})," in the drive. If no blob exists, returns ",(0,n.jsx)(r.code,{children:"null"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["It also returns ",(0,n.jsx)(r.code,{children:"null"})," for symbolic links."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-js",children:"{\n  follow: false, // Follow symlinks, 16 max or throws an error\n  wait: true, // Wait for block to be downloaded\n  timeout: 0 // Wait at max some milliseconds (0 means no timeout)\n}\n"})}),"\n",(0,n.jsx)(r.h4,{id:"drive.entry",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const entry = await drive.entry(path, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns the entry at ",(0,n.jsx)(r.code,{children:"path"})," in the drive. It looks like this:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"{\n  seq: Number,\n  key: String,\n  value: {\n    executable: Boolean, // Whether the blob at path is an executable\n    linkname: null, // If entry not symlink, otherwise a string to the entry this links to\n    blob: { // Hyperblobs id that can be used to fetch the blob associated with this entry\n      blockOffset: Number,\n      blockLength: Number,\n      byteOffset: Number,\n      byteLength: Number\n    },\n    metadata: null\n  }\n}\n"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-js",children:"{\n  follow: false, // Follow symlinks, 16 max or throws an error\n  wait: true, // Wait for block to be downloaded\n  timeout: 0 // Wait at max some milliseconds (0 means no timeout)\n}\n"})}),"\n",(0,n.jsx)(r.h4,{id:"drive.exists",children:(0,n.jsx)(r.code,{children:"const exists = await drive.exists(path)"})}),"\n",(0,n.jsxs)(r.p,{children:["Returns ",(0,n.jsx)(r.code,{children:"true"})," if the entry at ",(0,n.jsx)(r.code,{children:"path"})," does exists, otherwise ",(0,n.jsx)(r.code,{children:"false"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.del",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.del(path)"})})}),"\n",(0,n.jsxs)(r.p,{children:["Deletes the file at ",(0,n.jsx)(r.code,{children:"path"})," from the drive."]}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsx)(r.p,{children:"\u2139\ufe0f The underlying blob is not deleted, only the reference in the file structure."}),"\n"]}),"\n",(0,n.jsx)(r.h4,{id:"drive.compare",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const comparison = drive.compare(entryA, entryB)"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns ",(0,n.jsx)(r.code,{children:"0"})," if entries are the same, ",(0,n.jsx)(r.code,{children:"1"})," if ",(0,n.jsx)(r.code,{children:"entryA"})," is older, and ",(0,n.jsx)(r.code,{children:"-1"})," if ",(0,n.jsx)(r.code,{children:"entryB"})," is older."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.clear",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const cleared = await drive.clear(path, [options])"})})}),"\n",(0,n.jsx)(r.p,{children:"Deletes the blob from storage to free up space, but the file structure reference is kept."}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Property"}),(0,n.jsx)(r.th,{children:"Description"}),(0,n.jsx)(r.th,{children:"Type"}),(0,n.jsx)(r.th,{children:"Default"})]})}),(0,n.jsx)(r.tbody,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"diff"})})}),(0,n.jsxs)(r.td,{children:["Returned ",(0,n.jsx)(r.code,{children:"cleared"})," bytes object is null unless enabled"]}),(0,n.jsx)(r.td,{children:"Boolean"}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"false"})})]})})]}),"\n",(0,n.jsx)(r.h4,{id:"drive.clearall",children:(0,n.jsx)(r.code,{children:"const cleared = await drive.clearAll([options])"})}),"\n",(0,n.jsxs)(r.p,{children:["Deletes all the blobs from storage to free up space, similar to how ",(0,n.jsx)(r.code,{children:"drive.clear()"})," works."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Property"}),(0,n.jsx)(r.th,{children:"Description"}),(0,n.jsx)(r.th,{children:"Type"}),(0,n.jsx)(r.th,{children:"Default"})]})}),(0,n.jsx)(r.tbody,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"diff"})})}),(0,n.jsxs)(r.td,{children:["Returned ",(0,n.jsx)(r.code,{children:"cleared"})," bytes object is null unless enabled"]}),(0,n.jsx)(r.td,{children:"Boolean"}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"false"})})]})})]}),"\n",(0,n.jsx)(r.h4,{id:"drive.purge",children:(0,n.jsx)(r.code,{children:"await drive.purge()"})}),"\n",(0,n.jsx)(r.p,{children:"Purges both cores (db and blobs) from storage, completely removing all the drive's data."}),"\n",(0,n.jsx)(r.h4,{id:"drive.symlink",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.symlink(path, linkname)"})})}),"\n",(0,n.jsxs)(r.p,{children:["Creates an entry in drive at ",(0,n.jsx)(r.code,{children:"path"})," that points to the entry at ",(0,n.jsx)(r.code,{children:"linkname"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["If a blob entry currently exists at ",(0,n.jsx)(r.code,{children:"path"})," then it will get overwritten and ",(0,n.jsx)(r.code,{children:"drive.get(key)"})," will return ",(0,n.jsx)(r.code,{children:"null"}),", while ",(0,n.jsx)(r.code,{children:"drive.entry(key)"})," will return the entry with symlink information."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.batch",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const batch = drive.batch()"})})}),"\n",(0,n.jsx)(r.p,{children:"Useful for atomically mutating the drive, has the same interface as Hyperdrive."}),"\n",(0,n.jsx)(r.h4,{id:"drive.flush",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await batch.flush()"})})}),"\n",(0,n.jsx)(r.p,{children:"Commit a batch of mutations to the underlying drive."}),"\n",(0,n.jsx)(r.h4,{id:"drive.list",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const stream = drive.list(folder, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns a stream of all entries in the drive at paths prefixed with ",(0,n.jsx)(r.code,{children:"folder"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Property"}),(0,n.jsx)(r.th,{children:"Description"}),(0,n.jsx)(r.th,{children:"Type"}),(0,n.jsx)(r.th,{children:"Default"})]})}),(0,n.jsx)(r.tbody,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"recursive"})})}),(0,n.jsx)(r.td,{children:"whether to descend into all subfolders or not"}),(0,n.jsx)(r.td,{children:"Boolean"}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"true"})})]})})]}),"\n",(0,n.jsx)(r.h4,{id:"drive.readdir",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const stream = drive.readdir(folder)"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns a stream of all subpaths of entries in the drive stored at paths prefixed by ",(0,n.jsx)(r.code,{children:"folder"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.entries",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const stream = await drive.entries([range], [options])"})})}),"\n",(0,n.jsx)(r.p,{children:"Returns a read stream of entries in the drive."}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," are the same as ",(0,n.jsx)(r.code,{children:"Hyperbee().createReadStream([range], [options])"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.mirror",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const mirror = drive.mirror(out, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Mirrors this drive into another. Returns a ",(0,n.jsx)(r.a,{href:"/pear-docs/references/helpers/mirrordrive",children:(0,n.jsx)(r.code,{children:"MirrorDrive"})})," instance constructed with ",(0,n.jsx)(r.code,{children:"options"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["Call ",(0,n.jsx)(r.code,{children:"await mirror.done()"})," to wait for the mirroring to finish."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.watch",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const watcher = drive.watch([folder])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns an iterator that listens on ",(0,n.jsx)(r.code,{children:"folder"})," to yield changes, by default on ",(0,n.jsx)(r.code,{children:"/"}),"."]}),"\n",(0,n.jsx)(r.p,{children:"Usage example:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"for await (const [current, previous] of watcher) {\n  console.log(current.version)\n  console.log(previous.version)\n}\n"})}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"current"})," and ",(0,n.jsx)(r.code,{children:"previous"})," are the snapshots that are auto-closed before next value."]}),"\n",(0,n.jsx)(r.p,{children:"Do not close those snapshots as they're used internally, let them be auto-closed."}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"Methods:"}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.code,{children:"await watcher.ready()"})}),"\n",(0,n.jsx)(r.p,{children:"Waits until the watcher is loaded and detecting changes."}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.code,{children:"await watcher.destroy()"})}),"\n",(0,n.jsxs)(r.p,{children:["Stops the watcher. I can also be stopped by using ",(0,n.jsx)(r.code,{children:"break"})," in the ",(0,n.jsx)(r.code,{children:"for await"})," loop."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.createreadstream",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const rs = drive.createReadStream(path, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns a stream to read out the blob stored in the drive at ",(0,n.jsx)(r.code,{children:"path"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"{\n  start: Number, // `start` and `end` are inclusive\n  end: Number,\n  length: Number, // `length` overrides `end`, they're not meant to be used together\n  wait: true, // Wait for blocks to be downloaded\n  timeout: 0 // Wait at max some milliseconds (0 means no timeout)\n}\n"})}),"\n",(0,n.jsx)(r.h4,{id:"drive.createwritestream",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const ws = drive.createWriteStream(path, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Stream a blob into the drive at ",(0,n.jsx)(r.code,{children:"path"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Property"}),(0,n.jsx)(r.th,{children:"Description"}),(0,n.jsx)(r.th,{children:"Type"}),(0,n.jsx)(r.th,{children:"Default"})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"executable"})})}),(0,n.jsx)(r.td,{children:"whether the blob is executable or not"}),(0,n.jsx)(r.td,{children:"Boolean"}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"true"})})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"metadata"})})}),(0,n.jsx)(r.td,{children:"Extended file information i.e., arbitrary JSON value"}),(0,n.jsx)(r.td,{children:"Object"}),(0,n.jsx)(r.td,{children:(0,n.jsx)(r.code,{children:"null"})})]})]})]}),"\n",(0,n.jsx)(r.h4,{id:"drive.download",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.download(folder, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Downloads the blobs corresponding to all entries in the drive at paths prefixed with ",(0,n.jsx)(r.code,{children:"folder"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," are the same as those for ",(0,n.jsx)(r.code,{children:"drive.list(folder, [options])"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.checkout",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const snapshot = drive.checkout(version)"})})}),"\n",(0,n.jsx)(r.p,{children:"Gets a read-only snapshot of a previous version."}),"\n",(0,n.jsx)(r.h4,{id:"drive.diff",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const stream = drive.diff(version, folder, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Creates a stream of shallow changes to ",(0,n.jsx)(r.code,{children:"folder"})," between ",(0,n.jsx)(r.code,{children:"version"})," and ",(0,n.jsx)(r.code,{children:"drive.version"}),"."]}),"\n",(0,n.jsx)(r.p,{children:"Each entry is sorted by key and looks like this:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"{\n  left: Object, // Entry in folder at drive.version for some path\n  right: Object // Entry in folder at drive.checkout(version) for some path\n}\n"})}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsxs)(r.p,{children:["\u2139\ufe0f If an entry exists in ",(0,n.jsx)(r.code,{children:"drive.version"})," of the ",(0,n.jsx)(r.code,{children:"folder"})," but not in ",(0,n.jsx)(r.code,{children:"version"}),", then ",(0,n.jsx)(r.code,{children:"left"})," is set and ",(0,n.jsx)(r.code,{children:"right"})," will be ",(0,n.jsx)(r.code,{children:"null"}),", and vice versa."]}),"\n"]}),"\n",(0,n.jsx)(r.h4,{id:"drive.downloaddiff",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.downloadDiff(version, folder, [options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Downloads all the blobs in ",(0,n.jsx)(r.code,{children:"folder"})," corresponding to entries in ",(0,n.jsx)(r.code,{children:"drive.checkout(version)"})," that are not in ",(0,n.jsx)(r.code,{children:"drive.version"}),"."]}),"\n",(0,n.jsxs)(r.p,{children:["In other words, downloads all the blobs added to ",(0,n.jsx)(r.code,{children:"folder"})," up to ",(0,n.jsx)(r.code,{children:"version"})," of the drive."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.downloadrange",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"await drive.downloadRange(dbRanges, blobRanges)"})})}),"\n",(0,n.jsxs)(r.p,{children:["Downloads the entries and blobs stored in the ",(0,n.jsx)(r.a,{href:"https://github.com/holepunchto/hypercore#const-range--coredownloadrange",children:"ranges"})," ",(0,n.jsx)(r.code,{children:"dbRanges"})," and ",(0,n.jsx)(r.code,{children:"blobRanges"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.findingpeers",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const done = drive.findingPeers()"})})}),"\n",(0,n.jsx)(r.p,{children:"Indicates to Hyperdrive that users are finding peers in the background, requests will be on hold until this is done."}),"\n",(0,n.jsxs)(r.p,{children:["Call ",(0,n.jsx)(r.code,{children:"done()"})," when the current discovery iteration is done, i.e., after ",(0,n.jsx)(r.code,{children:"swarm.flush()"})," finishes."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.replicate",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const stream = drive.replicate(isInitiatorOrStream)"})})}),"\n",(0,n.jsx)(r.p,{children:"Usage example:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"const swarm = new Hyperswarm()\nconst done = drive.findingPeers()\nswarm.on('connection', (socket) => drive.replicate(socket))\nswarm.join(drive.discoveryKey)\nswarm.flush().then(done, done)\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Learn more about how replicate works at ",(0,n.jsx)(r.a,{href:"https://github.com/holepunchto/corestore#const-stream--storereplicateoptsorstream",children:"corestore.replicate"}),"."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.update",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const updated = await drive.update([options])"})})}),"\n",(0,n.jsxs)(r.p,{children:["Waits for initial proof of the new drive version until all ",(0,n.jsx)(r.code,{children:"findingPeers"})," are done."]}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.code,{children:"options"})," include:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"{\n  wait: false\n}\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Use ",(0,n.jsx)(r.code,{children:"drive.findingPeers()"})," or ",(0,n.jsx)(r.code,{children:"{ wait: true }"})," to make await ",(0,n.jsx)(r.code,{children:"drive.update()"})," blocking."]}),"\n",(0,n.jsx)(r.h4,{id:"drive.getblobs",children:(0,n.jsx)(r.strong,{children:(0,n.jsx)(r.code,{children:"const blobs = await drive.getBlobs()"})})}),"\n",(0,n.jsxs)(r.p,{children:["Returns the ",(0,n.jsx)(r.a,{href:"https://github.com/holepunchto/hyperblobs",children:"Hyperblobs"})," instance storing the blobs indexed by drive entries."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"await drive.put('/file.txt', Buffer.from('hi'))\n\nconst buffer1 = await drive.get('/file.txt')\n\nconst blobs = await drive.getBlobs()\nconst entry = await drive.entry('/file.txt')\nconst buffer2 = await blobs.get(entry.value.blob)\n\n// => buffer1 and buffer2 are equals\n"})})]})}function a(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,r,i)=>{i.d(r,{R:()=>l,x:()=>o});var d=i(6540);const n={},s=d.createContext(n);function l(e){const r=d.useContext(s);return d.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),d.createElement(s.Provider,{value:r},e.children)}}}]);