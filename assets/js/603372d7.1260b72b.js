"use strict";(globalThis.webpackChunkpear_docs_docusarus=globalThis.webpackChunkpear_docs_docusarus||[]).push([[7427],{6739:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>p});const r=JSON.parse('{"id":"how-to/connect-two-pears-with-hyper-dht","title":"How to connect two Peers by key with Hyperdht","description":"HyperDHT helps clients connect to a server peer with a known public key. HyperDHT uses a series of holepunching techniques to establish direct connections between the peers, even if they\'re located on home networks with tricky NATs.","source":"@site/docs/how-to/connect-two-pears-with-hyper-dht.md","sourceDirName":"how-to","slug":"/how-to/connect-two-pears-with-hyper-dht","permalink":"/pear-docs/how-to/connect-two-pears-with-hyper-dht","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/how-to/connect-two-pears-with-hyper-dht.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Best Practices","permalink":"/pear-docs/getting-started/best-practices"},"next":{"title":"How to connect to many peers by topic with Hyperswarm","permalink":"/pear-docs/how-to/connect-many-pears-with-hyper-swarm"}}');var o=t(4848),s=t(8453);const i={},c="How to connect two Peers by key with Hyperdht",a={},p=[];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"how-to-connect-two-peers-by-key-with-hyperdht",children:"How to connect two Peers by key with Hyperdht"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"../building-blocks/hyperdht.md",children:(0,o.jsx)(n.code,{children:"HyperDHT"})})," helps clients connect to a server peer with a known public key. HyperDHT uses a series of holepunching techniques to establish direct connections between the peers, even if they're located on home networks with tricky NATs."]}),"\n",(0,o.jsx)(n.p,{children:"In the HyperDHT, peers are identified by a public key, not by an IP address. The public key is looked up in a decentralized hash table, which maps the key to an IP address and port. This means users can connect to each other irrespective of their location, even if they move between different networks."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["HyperDHT's holepunching will fail if both the client peer and the server peer are on randomizing ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Network_address_translation",children:"NATs"}),", in which case the connection must be relayed through a third peer. HyperDHT does not do any relaying by default."]}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"For example, Keet implements its relaying system wherein other call participants can serve as relays -- the more participants in the call, the stronger overall connectivity becomes."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Use the HyperDHT to create a basic CLI chat app where a client peer connects to a server peer by public key."}),"\n",(0,o.jsxs)(n.p,{children:["This example consists of two applications: ",(0,o.jsx)(n.code,{children:"client-app"})," and ",(0,o.jsx)(n.code,{children:"server-app"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"server-app"})," will create a key pair and then start a server that will listen on the generated key pair. The public key is logged into the console. Copy it for instantiating the client."]}),"\n",(0,o.jsxs)(n.p,{children:["Create the ",(0,o.jsx)(n.code,{children:"server-app"})," project with the following commands:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"mkdir server-app\ncd server-app\npear init -y -t terminal\nnpm install hyperdht b4a bare-process\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Alter ",(0,o.jsx)(n.code,{children:"server-app/index.js"})," to the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import DHT from 'hyperdht'\nimport b4a from 'b4a'\nimport process from 'bare-process'\n\nconst dht = new DHT()\n\n// This keypair is the peer identifier in the DHT\nconst keyPair = DHT.keyPair()\n\nconst server = dht.createServer(conn => {\n  console.log('got connection!')\n  process.stdin.pipe(conn).pipe(process.stdout)\n})\n\nserver.listen(keyPair).then(() => {\n  console.log('listening on:', b4a.toString(keyPair.publicKey, 'hex'))\n})\n\n// Unnannounce the public key before exiting the process\n// (This is not a requirement, but it helps avoid DHT pollution)\nPear.teardown(() => server.close())\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Open the ",(0,o.jsx)(n.code,{children:"server-app"})," with ",(0,o.jsx)(n.code,{children:"pear run --dev ."}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["In another terminal create the ",(0,o.jsx)(n.code,{children:"client-app"})," project with the following commands:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"mkdir client-app\ncd client-app\npear init -y -t terminal\nnpm install hyperdht b4a bare-process\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Alter ",(0,o.jsx)(n.code,{children:"client-app/index.js"})," to the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import DHT from 'hyperdht'\nimport b4a from 'b4a'\nimport process from 'bare-process'\n\nconst key = Pear.config.args[0]\nif (!key) throw new Error('provide a key')\n\nconsole.log('Connecting to:', key)\nconst publicKey = b4a.from(key, 'hex')\n\nconst dht = new DHT()\nconst conn = dht.connect(publicKey)\nconn.once('open', () => console.log('got connection!'))\n\nprocess.stdin.pipe(conn).pipe(process.stdout)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Run the client passing it the key from the server:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"pear run --dev . <SUPPLY KEY HERE>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"client-app"})," will spin up a client, and the public key copied earlier must be supplied as a command line argument for connecting to the server. The client process will log ",(0,o.jsx)(n.code,{children:"got connection"})," into the console when it connects to the server."]}),"\n",(0,o.jsx)(n.p,{children:"Once it's connected, try typing in both terminals."})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);