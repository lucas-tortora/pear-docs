"use strict";(globalThis.webpackChunkpear_docs_docusarus=globalThis.webpackChunkpear_docs_docusarus||[]).push([[2341],{6085:(e,r,o)=>{o.r(r),o.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"how-to/manage-multiple-hypercores-with-corestore","title":"How to work with many Hypercores using Corestore","description":"An append-only log is powerful on its own, but it\'s most useful as a building block for constructing larger data structures, such as databases or filesystems. Building these data structures often requires many cores, each with different responsibilities. For example, Hyperdrive uses one core to store file metadata and another to store file contents.","source":"@site/docs/how-to/manage-multiple-hypercores-with-corestore.md","sourceDirName":"how-to","slug":"/how-to/manage-multiple-hypercores-with-corestore","permalink":"/pear-docs/how-to/manage-multiple-hypercores-with-corestore","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/how-to/manage-multiple-hypercores-with-corestore.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"How to replicate and persist with Hypercore","permalink":"/pear-docs/how-to/replicate-and-persist-with-hyper-core"},"next":{"title":"How to create a full peer-to-peer filesystem with Hyperdrive","permalink":"/pear-docs/how-to/create-a-full-peer-to-peer-filesystem-with-hyperdrive"}}');var t=o(4848),s=o(8453);const a={},i="How to work with many Hypercores using Corestore",c={},l=[];function d(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"how-to-work-with-many-hypercores-using-corestore",children:"How to work with many Hypercores using Corestore"})}),"\n",(0,t.jsx)(r.p,{children:"An append-only log is powerful on its own, but it's most useful as a building block for constructing larger data structures, such as databases or filesystems. Building these data structures often requires many cores, each with different responsibilities. For example, Hyperdrive uses one core to store file metadata and another to store file contents."}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.a,{href:"../helpers/corestore.md",children:(0,t.jsx)(r.code,{children:"Corestore"})})," is a Hypercore factory that makes it easier to manage large collections of named Hypercores. This how-to demonstrates a pattern often in use: co-replicating many cores using Corestore, where several 'internal cores' are linked to from a primary core. Only the primary core is announced on the swarm -- the keys for the others are recorded inside of that core."]}),"\n",(0,t.jsxs)(r.p,{children:["In ",(0,t.jsx)(r.a,{href:"./replicate-and-persist-with-hypercore.md",children:"How to replicate and persist with Hypercore"}),", only single Hypercore instance was replicated. But in this how-to, we will replicate a single Corestore instance, which will internally manage the replication of a collection of Hypercores. We will achieve this with two Pear Terminal Applications: ",(0,t.jsx)(r.code,{children:"multicore-writer-app"})," and ",(0,t.jsx)(r.code,{children:"multicore-reader-app"}),"."]}),"\n",(0,t.jsxs)(r.blockquote,{children:["\n",(0,t.jsx)(r.p,{children:"Only one Corestore per application is needed. This is the recommended best practices to make managing Hypercores efficient and to avoid pitfalls from having multiple Corestores. A single Corestore will:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Manage multiple sessions for the same Hypercore."}),"\n",(0,t.jsx)(r.li,{children:"Requires only one replication stream per peer connection."}),"\n",(0,t.jsx)(r.li,{children:"Simplifies referring to Hypercores by a name."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Create the ",(0,t.jsx)(r.code,{children:"multicore-writer-app"})," project with these commands:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"mkdir multicore-writer-app\ncd multicore-writer-app\npear init -y -t terminal\nnpm install bare-process corestore hyperswarm b4a\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Alter the generated ",(0,t.jsx)(r.code,{children:"multicore-writer-app/index.js"})," file to the following"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"import Hyperswarm from 'hyperswarm'\nimport Corestore from 'corestore'\nimport b4a from 'b4a'\nimport process from 'bare-process'\n\nconst store = new Corestore(Pear.config.storage)\nconst swarm = new Hyperswarm()\nPear.teardown(() => swarm.destroy())\n\n// A name is a purely-local, and maps to a key pair. It's not visible to readers.\n// Since a name always corresponds to a key pair, these are all writable\nconst core1 = store.get({ name: 'core-1', valueEncoding: 'json' })\nconst core2 = store.get({ name: 'core-2' })\nconst core3 = store.get({ name: 'core-3' })\nawait Promise.all([core1.ready(), core2.ready(), core3.ready()])\n\nconsole.log('main core key:', b4a.toString(core1.key, 'hex'))\n\n// Here we'll only join the swarm with the core1's discovery key\n// We don't need to announce core2 and core3, because they'll be replicated with core1\nswarm.join(core1.discoveryKey)\n\n// Corestore replication internally manages to replicate every loaded core\n// Corestore *does not* exchange keys (read capabilities) during replication.\nswarm.on('connection', (conn) => store.replicate(conn))\n\n// Since Corestore does not exchange keys, they need to be exchanged elsewhere.\n// Here, we'll record the other keys in the first block of core1.\nif (core1.length === 0) {\n  await core1.append({\n    otherKeys: [core2, core3].map((core) => b4a.toString(core.key, 'hex'))\n  })\n}\n\n// Record all short messages in core2, and all long ones in core3\nprocess.stdin.on('data', (data) => {\n  if (data.length < 5) {\n    console.log('appending short data to core2')\n    core2.append(data)\n  } else {\n    console.log('appending long data to core3')\n    core3.append(data)\n  }\n})\n"})}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"multicore-writer-app"})," uses a Corestore instance to create three Hypercores, which are then replicated with other peers using ",(0,t.jsx)(r.code,{children:"Hyperswarm"}),". The keys for the second and third cores are stored in the first core (the first core bootstraps the system). Messages entered into the command line are written into the second and third cores, depending on the length of the message. The main core key logged into the command line so that it can be passed to the ",(0,t.jsx)(r.code,{children:"multicore-reader-app"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"multicore-reader-app"})," connects to the previous peer with ",(0,t.jsx)(r.code,{children:"Hyperswarm"})," and replicates the local ",(0,t.jsx)(r.code,{children:"Corestore"})," instance to receive the data from it. This requires the copied key to be supplied as an argument when executing the file, which will then be used to create a core with the same public key as the other peer (i.e., the same discovery key for both the reader and writer peers)."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"mkdir multicore-reader-app\ncd multicore-reader-app\npear init -y -t terminal\nnpm install corestore hyperswarm b4a\n"})}),"\n",(0,t.jsxs)(r.p,{children:["Alter the generated ",(0,t.jsx)(r.code,{children:"multicore-reader-app/index.js"})," file to the following"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"import Corestore from 'corestore'\nimport Hyperswarm from 'hyperswarm'\nimport b4a from 'b4a'\n\nif (!Pear.config.args[0]) throw new Error('provide a key')\n\nconst key = b4a.from(Pear.config.args[0], 'hex')\n\nconst store = new Corestore(Pear.config.storage)\nawait store.ready()\n\nconst swarm = new Hyperswarm()\nPear.teardown(() => swarm.destroy())\n\n// replication of corestore instance on every connection\nswarm.on('connection', (conn) => store.replicate(conn))\n\n// creation/getting of a hypercore instance using the key passed\nconst core = store.get({ key, valueEncoding: 'json' })\n// wait till all the properties of the hypercore instance are initialized\nawait core.ready()\n\nswarm.join(core.discoveryKey)\nawait swarm.flush()\n\n// update the meta-data of the hypercore instance\nawait core.update()\n\nif (core.length === 0) {\n  throw new Error('Could not connect to the writer peer')\n}\n\n// getting cores using the keys stored in the first block of main core\nconst { otherKeys } = await core.get(0)\nfor (const key of otherKeys) {\n  const core = store.get({ key: b4a.from(key, 'hex') })\n  // on every append to the hypercore, \n  // download the latest block of the core and log it to the console\n  core.on('append', () => {\n    const seq = core.length - 1\n    core.get(seq).then(block => {\n      console.log(`Block ${seq} in Core ${key}: ${block}`) \n    })\n  })\n}\n"})}),"\n",(0,t.jsxs)(r.p,{children:["In one terminal, open ",(0,t.jsx)(r.code,{children:"multicore-writer-app"})," with ",(0,t.jsx)(r.code,{children:"pear run --dev ."}),"."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"cd  multicore-writer-app\npear run --dev .\n"})}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"multicore-writer-app"})," will output the main core key."]}),"\n",(0,t.jsxs)(r.p,{children:["In another terminal, open the ",(0,t.jsx)(r.code,{children:"multicore-reader-app"})," and pass it the key:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"cd multicore-reader-app\npear run --dev . <SUPPLY THE KEY HERE>\n"})}),"\n",(0,t.jsx)(r.p,{children:"As inputs are made to the terminal running the writer application, outputs should be shown in the terminal running the reader application."})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,o)=>{o.d(r,{R:()=>a,x:()=>i});var n=o(6540);const t={},s=n.createContext(t);function a(e){const r=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);